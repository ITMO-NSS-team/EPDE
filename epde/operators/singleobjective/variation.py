#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jun  2 15:43:19 2021

@author: mike_ubuntu
"""

from operator import eq
import numpy as np
from copy import deepcopy

from typing import Union

from functools import partial

from epde.structure.structure_template import check_uniqueness
from epde.optimizers.moeadd.moeadd import ParetoLevels
from epde.optimizers.single_criterion.optimizer import Population

from epde.supplementary import detect_similar_terms, flatten
from epde.decorators import HistoryExtender, ResetEquationStatus

from epde.operators.utils.template import CompoundOperator, add_base_param_to_operator
from epde.operators.multiobjective.moeadd_specific import get_basic_populator_updater
from epde.operators.multiobjective.mutations import get_basic_mutation


class PopulationLevelCrossover(CompoundOperator):
    """
    The crossover operator combines parameter crossover for terms with identical symbolic structures but differing parameters and exchanges entire terms between dissimilar equations.
    
    Key attributes:
    
    *   `suboperators`: A dictionary containing sub-operators for parent selection, parameter crossover, term crossover, coefficient calculation, and fitness evaluation. The keys are strings: 'Selection', 'Param\_crossover', 'Term\_crossover', 'Coeff\_calc', and 'Fitness\_eval'. The values are the corresponding operator objects.
    
    
        Methods:
        -----------
        apply(population)
            return the new population, created with the noted operators and containing both parent individuals and their offsprings.    
        copy_properties_to
    """

    key = 'PopulationLevelCrossover'

    def apply(self, objective : Union[ParetoLevels, Population], arguments : dict):
        """
        Generates new candidate solutions by combining genetic material from selected parent equations through crossover.
        
        This method selects parent equations based on their `crossover_times` attribute, performs crossover using a sub-operator, and integrates the resulting offspring into the population. This process aims to explore the solution space more effectively by creating new equation structures that inherit characteristics from successful parents.
        
        Args:
            objective (Union[ParetoLevels, Population]): The population or Pareto level to which the crossover operator is applied.
            arguments (dict): A dictionary containing arguments for the crossover operator and its sub-operators.
        
        Returns:
            Union[ParetoLevels, Population]: The updated population or Pareto level, now including the offspring generated by crossover.
        """
        self_args, subop_args = self.parse_suboperator_args(arguments = arguments)        
        
        crossover_pool = []
        for solution in objective.population:
            crossover_pool.extend([solution,] * solution.crossover_times())
            solution.reset_counter()

        if len(crossover_pool) == 0:
            raise ValueError('crossover pool not created, probably solution.crossover_selected_times error')
        np.random.shuffle(crossover_pool)
        if len(crossover_pool) % 2:
            crossover_pool = crossover_pool[:-1]
        crossover_pool = np.array(crossover_pool, dtype = object).reshape((-1,2))

        offsprings = []
        for pair_idx in np.arange(crossover_pool.shape[0]):
            if len(crossover_pool[pair_idx, 0].vals) != len(crossover_pool[pair_idx, 1].vals):
                raise IndexError('Equations have diffferent number of terms')
            new_system_1 = deepcopy(crossover_pool[pair_idx, 0])
            new_system_2 = deepcopy(crossover_pool[pair_idx, 1])
            new_system_1.reset_state(); new_system_2.reset_state()
            
            new_system_1, new_system_2 = self.suboperators['chromosome_crossover'].apply(objective = (new_system_1, new_system_2), 
                                                                                         arguments = subop_args['chromosome_crossover'])
            offsprings.extend([new_system_1, new_system_2])

        # TODO: maybe a better operator will fit here?
        if isinstance(objective, ParetoLevels):
            objective.unplaced_candidates = offsprings
        elif isinstance(objective, Population):
            objective.population.extend(offsprings)
        return objective

    def use_default_tags(self):
        """
        Applies a predefined set of tags to categorize this crossover operator.
        
        This tagging helps in organizing and filtering operators based on their characteristics within the evolutionary process.
        
        Args:
            self: The object instance.
        
        Returns:
            None.
        
        Sets:
            _tags (set): A set containing the default tags: 'crossover', 'population level', 'contains suboperators', and 'standard'.
        """
        self._tags = {'crossover', 'population level', 'contains suboperators', 'standard'}


class ChromosomeCrossover(CompoundOperator):
    """
    Applies crossover at the chromosome level using sub-operators.
    
        This class facilitates the crossover of genetic material between two parent
        chromosomes to produce two offspring chromosomes. It utilizes sub-operators
        to perform crossover at a finer level of granularity.
    
        Class Attributes:
        - equation_crossover
        - parameter_crossover
    
        Class Methods:
        - apply:
    """

    key = 'ChromosomeCrossover'

    def apply(self, objective : tuple, arguments : dict):
        """
        Applies crossover between two objectives (parents) to create two offspring.
        
                This method facilitates the evolutionary search for optimal equation structures by
                combining genetic material from two parent objectives. It performs crossover at both
                the equation and parameter levels, leveraging sub-operators to generate new candidate
                solutions. This process aims to explore the search space efficiently and discover
                equation forms that better fit the observed data.
        
                Args:
                    objective (tuple): A tuple containing two objectives (parents) to be crossed over.
                    arguments (dict): A dictionary containing arguments for the crossover operation,
                        including arguments for sub-operators.
        
                Returns:
                    tuple: A tuple containing two objectives (offspring) resulting from the crossover.
        """
        self_args, subop_args = self.parse_suboperator_args(arguments = arguments)
   
        assert objective[0].vals.same_encoding(objective[1].vals)
        # offspring_1 = deepcopy(objective[0]); offspring_2 = deepcopy(objective[1])      
        offspring_1 = objective[0]; offspring_2 = objective[1]
                
        eqs_keys = objective[0].vals.equation_keys; params_keys = objective[1].vals.params_keys
        for eq_key in eqs_keys:
            temp_eq_1, temp_eq_2 = self.suboperators['equation_crossover'].apply(objective = (objective[0].vals[eq_key],
                                                                                              objective[1].vals[eq_key]),
                                                                                 arguments = subop_args['equation_crossover'])
            # print(f'PARENT 1: objective[0].vals[eq_key] is {objective[0].vals[eq_key].text_form}')
            # print(f'PARENT 2: objective[1].vals[eq_key] is {objective[1].vals[eq_key].text_form}')            
            # print(f'OFFSPRING: temp_eq_1.vals[eq_key] is {temp_eq_1.text_form}')
            objective[0].vals.replace_gene(gene_key = eq_key, value = temp_eq_1)
            offspring_2.vals.replace_gene(gene_key = eq_key, value = temp_eq_2)
            
        for param_key in params_keys:
            temp_param_1, temp_param_2 = self.suboperators['param_crossover'].apply(objective = (objective[0].vals[param_key],
                                                                                                 objective[1].vals[param_key]),
                                                                                    arguments = subop_args['param_crossover'])
            objective[0].vals.replace_gene(gene_key = param_key, value = temp_param_1)
            objective[1].vals.replace_gene(gene_key = param_key, value = temp_param_2)

            objective[0].vals.pass_parametric_gene(key = param_key, value = temp_param_1)
            objective[1].vals.pass_parametric_gene(key = param_key, value = temp_param_2)

        # print(f'OFFSPRING CROSSOVER: {[ind.text_form for ind in objective[0].vals]}')
        # print(f'OFFSPRING CROSSOVER: {[ind.text_form for ind in objective[1].vals]}')
        return objective[0], objective[1]

    def use_default_tags(self):
        """
        Applies a predefined set of tags to this operator.
        
        These tags categorize the operator based on its function and characteristics within the evolutionary process. This helps in managing and filtering operators based on their roles.
        
        Args:
            self: The object instance.
        
        Returns:
            None.
        
        Initializes:
            _tags (set): A set containing default tags: 'crossover', 'chromosome level', 'contains suboperators', and 'standard'.
        """
        self._tags = {'crossover', 'chromosome level', 'contains suboperators', 'standard'}


class MetaparamerCrossover(CompoundOperator):
    """
    Applies crossover at the level of metaparameters.
    
        This class is designed to perform crossover operations on metaparameters,
        facilitating the exploration of different configurations in optimization
        processes.
    """

    key = 'MetaparamerCrossover'

    def apply(self, objective : tuple, arguments : dict):
        """
        Applies a blending crossover to the objective values, creating new solutions that inherit characteristics from both parents. This operation refines the search for optimal equation structures by exploring combinations of existing high-performing solutions.
        
                Args:
                    objective (tuple): A tuple containing two objective values representing the fitness of parent equations.
                    arguments (dict): A dictionary of arguments for the crossover operator, including parameters like `metaparam_proportion`.
        
                Returns:
                    tuple: A tuple containing two offspring values, representing the fitness of the newly generated equation structures.
        """
        self_args, subop_args = self.parse_suboperator_args(arguments = arguments)
        
        offspring_1 = objective[0] + self.params['metaparam_proportion'] * (objective[1] - objective[0])
        offspring_2 = objective[0] + (1 - self.params['metaparam_proportion']) * (objective[1] - objective[0])
        return offspring_1, offspring_2

    def use_default_tags(self):
        """
        Uses a predefined set of tags to categorize the crossover operator.
        
                This method overwrites any existing tags, ensuring the operator is correctly identified 
                within the evolutionary process. This is important for filtering and selecting appropriate
                operators during the search for differential equations.
        
                Args:
                    self: The object instance.
        
                Returns:
                    None.
        """
        self._tags = {'crossover', 'gene level', 'no suboperators'}


class EquationCrossover(CompoundOperator):
    """
    Applies equation crossover to a pair of equations.
    
        This crossover method combines aspects of both sub-operator crossover and
        term crossover. It identifies similar terms in the equations and applies
        sub-operators to crossover these terms. It also applies term crossover to
        the remaining different terms, ensuring uniqueness of terms after crossover.
    """

    key = 'EquationCrossover'
    
    @HistoryExtender(f'\n -> performing equation crossover', 'ba')
    def apply(self, objective : tuple, arguments : dict):
        """
        Applies equation crossover to a pair of equation objects.
        
                This method aims to evolve better equation structures by exchanging genetic material
                between two parent equations. It identifies and recombines similar and dissimilar
                terms using specialized sub-operators, ensuring the resulting equations remain
                syntactically valid and diverse. This process facilitates the exploration of the
                equation search space, potentially leading to the discovery of more accurate or
                parsimonious models.
        
                Args:
                    objective (tuple): A tuple containing two equation objects to be crossed over.
                    arguments (dict): A dictionary containing arguments for the sub-operators.
        
                Returns:
                    tuple: A tuple containing the two modified equation objects after crossover.
        """
        self_args, subop_args = self.parse_suboperator_args(arguments = arguments)
        
        equation1_terms, equation2_terms = detect_similar_terms(objective[0], objective[1])
        assert len(equation1_terms[0]) == len(equation2_terms[0]) and len(equation1_terms[1]) == len(equation2_terms[1])
        same_num = len(equation1_terms[0]); similar_num = len(equation1_terms[1])
        objective[0].structure = flatten(equation1_terms); objective[1].structure = flatten(equation2_terms)
    
        for i in range(same_num, same_num + similar_num):
            temp_term_1, temp_term_2 = self.suboperators['term_param_crossover'].apply(objective = (objective[0].structure[i], 
                                                                                                    objective[1].structure[i]),
                                                                                       arguments = subop_args['term_param_crossover']) 
            if (check_uniqueness(temp_term_1, objective[0].structure[:i] + objective[0].structure[i+1:]) and 
                check_uniqueness(temp_term_2, objective[1].structure[:i] + objective[1].structure[i+1:])):                     
                objective[0].structure[i] = temp_term_1; objective[1].structure[i] = temp_term_2

        for i in range(same_num + similar_num, len(objective[0].structure)):
            if check_uniqueness(objective[0].structure[i], objective[1].structure) and check_uniqueness(objective[1].structure[i], objective[0].structure):
                objective[0].structure[i], objective[1].structure[i] = self.suboperators['term_crossover'].apply(objective = (objective[0].structure[i], 
                                                                                                                              objective[1].structure[i]),
                                                                                                               arguments = subop_args['term_crossover'])
                
        return objective[0], objective[1]

    def use_default_tags(self):
        """
        Uses a predefined set of tags to categorize the equation crossover operator.
        
                This method resets the operator's tags to a default set, ensuring consistent categorization and facilitating its identification within the EPDE framework. This is useful for maintaining a standard set of characteristics for the operator.
        
                Args:
                    self: The EquationCrossover instance.
        
                Returns:
                    None. The method modifies the `_tags` attribute of the object in place.
        """
        self._tags = {'crossover', 'gene level', 'contains suboperators', 'standard'}

class EquationExchangeCrossover(CompoundOperator):
    """
    Applies equation exchange crossover to a pair of objectives.
    
        Class Methods:
        - apply: Applies equation exchange crossover to a pair of objectives.
        - use_default_tags: Uses the default set of tags for this object.
    """

    key = 'EquationExchangeCrossover'
    
    @HistoryExtender(f'\n -> performing equation exchange crossover', 'ba')
    def apply(self, objective : tuple, arguments : dict):
        """
        Applies equation exchange crossover to a pair of objectives.
        
                This method facilitates the exploration of the search space by recombining equation structures. It swaps the 'structure' attributes of the two objective functions, effectively exchanging building blocks between them. This allows the evolutionary algorithm to explore new combinations of equation terms and potentially discover better-fitting models.
        
                Args:
                    objective (tuple): A tuple containing two objective objects, whose equation structures will be exchanged.
                    arguments (dict): A dictionary containing arguments for the operator and its sub-operators.
        
                Returns:
                    tuple: A tuple containing the two objective objects with their structures swapped, enabling the exploration of new equation combinations.
        """
        self_args, subop_args = self.parse_suboperator_args(arguments = arguments)
        
        objective[0].structure, objective[1].structure = objective[1].structure, objective[0].structure
        return objective[0], objective[1]

    def use_default_tags(self):
        """
        Uses a predefined set of tags to categorize the crossover operator.
        
                This method overwrites any existing tags, ensuring the operator is correctly identified within the equation discovery process. This is important for filtering and selecting appropriate operators during the evolutionary search.
        
                Args:
                    self: The EquationExchangeCrossover instance.
        
                Returns:
                    None.
        """
        self._tags = {'crossover', 'gene level', 'contains suboperators', 'standard'}


class TermParamCrossover(CompoundOperator):
    """
    Performs crossover between parent terms that share the same factor functions but differ in their factor parameters.
    
    
        Noteable attributes:
        -----------
        params : dict
            Inhereted from the Specific_Operator class. 
            Main key - 'proportion', value - proportion, in which the offsprings' parameter values are chosen.
    
        Methods:
        -----------
        apply(population)
            return the offspring terms, constructed as the parents' factors with parameter values, selected between the parents' ones.
    """

    key = 'TermParamCrossover'
    
    def apply(self, objective : tuple, arguments : dict):
        """
        Modifies the parameters of the parent terms' factors to create offspring terms.
        
                This method iterates through the factors (tokens) of the parent terms, and for each parameter within those factors (excluding 'power' and 'dim'), it performs a weighted average of the parameter values from both parents. This process effectively blends the characteristics of the parent terms, generating new terms with potentially improved fitness. The proportion of each parent's parameter value that contributes to the offspring is determined by the `term_param_proportion` parameter. This parameter controls the balance between exploration and exploitation in the search for optimal equation structures.
        
                Args:
                    objective (tuple): A tuple containing two `Term` objects, representing the parent terms to be crossed over.
                    arguments (dict): A dictionary containing additional arguments required for the crossover operation.
        
                Returns:
                    tuple: A tuple containing two `Term` objects, representing the offspring terms generated by the crossover operation.
        """
        self_args, subop_args = self.parse_suboperator_args(arguments = arguments)
        
        # offspring_1 = deepcopy(objective[0]); offspring_2 = deepcopy(objective[1])
        objective[0].reset_saved_state(); objective[1].reset_saved_state()
        
        if len(objective[0].structure) != len(objective[1].structure):
            print([(token.label, token.params) for token in objective[0].structure], [(token.label, token.params) for token in objective[1].structure])
            raise Exception('Wrong terms passed:')
        for term1_token_idx in np.arange(len(objective[0].structure)):
            term2_token_idx = [i for i in np.arange(len(objective[1].structure)) 
                               if objective[1].structure[i].label == objective[0].structure[term1_token_idx].label][0]
            for param_idx, param_descr in objective[0].structure[term1_token_idx].params_description.items():
                if param_descr['name'] == 'power': power_param_idx = param_idx
                if param_descr['name'] == 'dim': dim_param_idx = param_idx                

            for param_idx in np.arange(objective[0].structure[term1_token_idx].params.size):
                if param_idx != power_param_idx and param_idx != dim_param_idx:
                    try:
                        objective[0].structure[term1_token_idx].params[param_idx] = (objective[0].structure[term1_token_idx].params[param_idx] + 
                                                                                     self.params['term_param_proportion'] 
                                                                                     * (objective[1].structure[term2_token_idx].params[param_idx] 
                                                                                        - objective[0].structure[term1_token_idx].params[param_idx]))
                    except KeyError:
                        print([(token.label, token.params) for token in objective[0].structure], [(token.label, token.params) for token in objective[1].structure])
                        raise Exception('Wrong set of parameters:', objective[0].structure[term1_token_idx].params_description, objective[1].structure[term1_token_idx].params_description)
                    objective[1].structure[term2_token_idx].params[param_idx] = (objective[0].structure[term1_token_idx].params[param_idx] + 
                                                                                (1 - self.params['term_param_proportion']) 
                                                                                * (objective[1].structure[term2_token_idx].params[param_idx] 
                                                                                - objective[0].structure[term1_token_idx].params[param_idx]))
        objective[0].reset_occupied_tokens(); objective[1].reset_occupied_tokens()
        return objective[0], objective[1]

    def use_default_tags(self):
        """
        Applies a pre-defined set of tags to this operator.
        
        This method resets the operator's tags to a default configuration, ensuring consistency in its identification and categorization within the evolutionary process. This is useful for standardizing the operator's behavior and characteristics.
        
        Args:
            self: The object instance.
        
        Returns:
            None.
        """
        self._tags = {'crossover', 'term level', 'exploitation', 'no suboperators', 'standard'}

class TermCrossover(CompoundOperator):
    """
    Performs crossover by exchanging complete terms between parent equations.
    
    
        Noteable attributes:
        -----------
        params : dict
            Inhereted from the Specific_Operator class. 
            Main key - 'crossover_probability', value - probabilty of the term exchange.
    
        Methods:
        -----------
        apply(population)
            return the offspring terms, which are the same parents' ones, but in different order, if the crossover occured.
            .
    """

    key = 'TermCrossover'
    
    def apply(self, objective : tuple, arguments : dict):
        """
        Performs crossover between two terms based on a defined probability.
        
                This method determines whether to swap the order of two parent terms
                to create offspring. The decision is based on a crossover probability
                and a check to ensure that the descriptive variable markers of the
                objectives are the same. This ensures that crossover only occurs
                between compatible terms, maintaining the integrity of the equation
                structure being evolved.
        
                Args:
                    objective (tuple): A tuple containing two Term objects (the parents).
                    arguments (dict): A dictionary containing arguments needed for the sub-operators.
        
                Returns:
                    tuple: A tuple containing two Term objects (the offspring). The order
                           may be swapped depending on the crossover probability.
        """
        self_args, subop_args = self.parse_suboperator_args(arguments = arguments)
        
        if (np.random.uniform(0, 1) <= self.params['crossover_probability'] and 
            objective[1].descr_variable_marker == objective[0].descr_variable_marker):
                return objective[1], objective[0]
        else:
                return objective[0], objective[1]
        
    def use_default_tags(self):
        """
        Sets the tags to a predefined default set.
        
        This method resets the internal tag set to a predefined default, ensuring
        consistency and adherence to standard configurations within the evolutionary
        process. This is useful for initializing or resetting the search strategy
        to a known state, promoting exploration of common equation structures.
        
        Args:
            self: The object instance.
        
        Returns:
            None.
        """
        self._tags = {'crossover', 'term level', 'exploration', 'no suboperators', 'standard'}


def get_singleobjective_variation(variation_params : dict = {}):
    """
    Creates and configures a population-level crossover operator for single-objective optimization.
    
        This method initializes and configures a set of crossover operators, including term parameter crossover,
        term crossover, equation crossover, and chromosome crossover, before combining them into a population-level
        crossover operator. It uses partial function application to inject base parameters into the operators.
        This setup is crucial for effectively exploring the space of possible equation structures by recombining
        different components of equations during the evolutionary search.
    
        Args:
            variation_params: A dictionary to store variation parameters.
    
        Returns:
            The configured PopulationLevelCrossover operator.
    """
    # TODO: generalize initiation with test runs and simultaneous parameter and object initiation.
    add_kwarg_to_operator = partial(add_base_param_to_operator, target_dict = variation_params)    

    term_param_crossover = TermParamCrossover(['term_param_proportion'])
    add_kwarg_to_operator(operator = term_param_crossover)
    term_crossover = TermCrossover(['crossover_probability'])
    add_kwarg_to_operator(operator = term_crossover)

    equation_crossover = EquationCrossover()

    chromosome_crossover = ChromosomeCrossover()

    pl_cross = PopulationLevelCrossover(['PBI_penalty'])
    add_kwarg_to_operator(operator = pl_cross)

    equation_crossover.set_suboperators(operators = {'term_param_crossover' : term_param_crossover, 
                                                     'term_crossover' : term_crossover})
    chromosome_crossover.set_suboperators(operators = {'equation_crossover' : equation_crossover},
                                          probas = {'equation_crossover' : [0.9, 0.1]})
    pl_cross.set_suboperators(operators = {'chromosome_crossover' : chromosome_crossover})
    return pl_cross


def get_multiobjective_variation(variation_params : dict = {}): # Rename function calls where necessary
    # TODO: generalize initiation with test runs and simultaneous parameter and object initiation.
    add_kwarg_to_operator = partial(add_base_param_to_operator, target_dict = variation_params)    

    term_param_crossover = TermParamCrossover(['term_param_proportion'])
    add_kwarg_to_operator(operator = term_param_crossover)
    term_crossover = TermCrossover(['crossover_probability'])
    add_kwarg_to_operator(operator = term_crossover)

    equation_crossover = EquationCrossover()
    metaparameter_crossover = MetaparamerCrossover(['metaparam_proportion'])
    add_kwarg_to_operator(operator = metaparameter_crossover)
    equation_exchange_crossover = EquationExchangeCrossover()

    chromosome_crossover = ChromosomeCrossover()

    pl_cross = PopulationLevelCrossover(['PBI_penalty'])
    add_kwarg_to_operator(operator = pl_cross)

    equation_crossover.set_suboperators(operators = {'term_param_crossover' : term_param_crossover, 
                                                     'term_crossover' : term_crossover})
    chromosome_crossover.set_suboperators(operators = {'equation_crossover' : [equation_crossover, equation_exchange_crossover],
                                                       'param_crossover' : metaparameter_crossover},
                                          probas = {'equation_crossover' : [0.9, 0.1]})
    pl_cross.set_suboperators(operators = {'chromosome_crossover' : chromosome_crossover})
    return pl_cross